# Generating Bindings and Writing Wrappers

A lot of the time you'll have a large amount of existing C (or C++, but more of 
that later) code which you need to integrate your Rust tools into, a great 
example of this is [OpenSSl][openssl] or [git][git]. Unless the C code is 
fairly small or trivial it's not going to be feasible to port to Rust, plus
why re-invent the wheel when you could be doing more interesting stuff?

Luckily with Rust you can have your cake and eat it too. As you'll already know
Rust can transparently call C functions as long as you have declarations for
them so the compiler knows what symbols to use. Enter [bindgen][bindgen].

Bindgen does all the hard work of parsing C-style header files and generating 
the equivalent Rust function definitions. They've also got a 
[great tutorial][tut] for getting started so I'm not going to bother 
reiterating the basics. Instead, we'll try to focus on the more high level 
stuff which comes with using a C library from Rust, seeing as the zero cost
abstractions and high level way of approaching things is probably why you're 
trying to do this FFI stuff in the first place!


## Getting Set Up

We'll be building on top of the [great tutorial][tut] I linked earlier to write
an idiomatic Rust wrapper around `bzip2`. I'll assume you've already read
through that tutorial and focus more on the next step, writing the actual
wrapper code and using common Rust patterns.

First we'll create a new crate:

```bash
$ cargo new bzip2
```

Then add `bindgen` as a dependency and tell `Cargo` about our build script
(which doesn't actually exist yet):

```
 name = "bzip2"
 version = "0.1.0"
 authors = ["Michael-F-Bryan <michaelfbryan@gmail.com>"]
+build = "build.rs"
 
 [dependencies]
+
+[build-dependencies]
+bindgen = "0.20.0"
```

`Bindgen` works by reading a `C`-style header file using `libclang`, then
it runs the preprocessor and creates bindings based on the output. Therefore, 
before we can start our build script we'll need a dummy header which pulls in
the `bzip2` library installed on your system.

```c
// wrapper.h
#include <bzlib.h>
```

Now we can create our `build.rs` script. This gets run before the crate is
compiled, and allows us to generate code at compile time.

```Rust
extern crate bindgen;

use std::env;
use std::path::PathBuf;

fn main() {
    println!("cargo:rustc-link-lib=bz2");

    let bindings = bindgen::Builder::default()
        .no_unstable_rust()
        .header("wrapper.h")
        .generate()
        .expect("Unable to generate bindings");

    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}
```

Let's compile everything created so far to make sure it actually works.

```bash
$ cargo build 
    Updating registry `https://github.com/rust-lang/crates.io-index`
Downloading bindgen v0.20.5
Downloading syntex_syntax v0.54.0
...
Finished debug [unoptimized + debuginfo] target(s) in 12.41 secs
```

So far, we haven't actually written any code so our `lib.rs` file should still 
just have the auto-generated `it_works()` test. If you want to view the
generated bindings, you'll see that it's not exactly the nicest Rust code to
look at...

```bash
$ find -name "bindings.rs"
./target/debug/build/bzip2-cd18fea72e03763e/out/bindings.rs
```

And here are a couple excerpts from that file:

```Rust
// selected output from ./target/debug/build/bzip2-cd18fea72e03763e/out/bindings.rs

/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}

...

pub const BZ_RUN: ::std::os::raw::c_uint = 0;
pub const BZ_FLUSH: ::std::os::raw::c_uint = 1;
pub const BZ_FINISH: ::std::os::raw::c_uint = 2;
pub const BZ_OK: ::std::os::raw::c_uint = 0;
pub const BZ_RUN_OK: ::std::os::raw::c_uint = 1;
pub const BZ_FLUSH_OK: ::std::os::raw::c_uint = 2;

...

#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub next_in: *mut ::std::os::raw::c_char,
    pub avail_in: ::std::os::raw::c_uint,
    pub total_in_lo32: ::std::os::raw::c_uint,
    pub total_in_hi32: ::std::os::raw::c_uint,
    pub next_out: *mut ::std::os::raw::c_char,
    pub avail_out: ::std::os::raw::c_uint,
    pub total_out_lo32: ::std::os::raw::c_uint,
    ...
}
pub type bz_stream = _bindgen_ty_1;
```

I usually like to put my FFI bindings in their own sub-module, we can now
replace the contents of `lib.rs` and recompile.

```Rust
pub mod ffi {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]

    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}
```

> **Note:** You'll notice I made the `ffi` module public. I've done this during
> the development stage so we can easily view the FFI bindings using 
> `cargo doc --open`. We'll make it private later on so users are forced to go
> through our Rust-ic API.


## Creating The Rust Wrapper

Now that we've got a basic crate and know our build system works (i.e.
`bindgen` is creating our bindings, and we can get started on wrapping the
`bzip2` library and giving it a safe API.

The best way to figure out how our wrapper API should look is to find existing
code and (roughly) copy that. Luckily `libbzip2` documents its low level
interface [on their website][libbzip2] and they explain how each of the
functions work. According to the docs, this is roughly how you'd compress some
data:

> That still looks complicated? Well, fair enough. The usual sequence of 
> calls for compressing a load of data is:
>
> 1. Get started with `BZ2_bzCompressInit()`.
> 
> Shovel data in and shlurp out its compressed form using zero or more calls 
> of `BZ2_bzCompress()` with action = `BZ_RUN`.
>
> Finish up. Repeatedly call `BZ2_bzCompress()` with action = `BZ_FINISH`, 
> copying out the compressed output, until `BZ_STREAM_END` is returned.
>
> Close up and go home. Call `BZ2_bzCompressEnd()`.

From this, my thinking is that you'll want some `Compressor` object which
contains the `bz_stream`. We'll run `BZ2_bzCompressInit()` in the constructor
and write a `Drop` impl which calls `BZ2_bzCompressEnd()`. The `Compressor` 
will also need a mutable reference to a `Read`er to read data from and a 
`Write`r to write the compressed data to. There should also be a `compress()`
method which internally just keeps calling the `BZ2_bzCompress()` function
until everything is finished.

Error handling should be fairly easy, all `libbzip2` functions return an
integer which corresponds to a error code, this should be fairly easy to map to
a Rust enum and we'll add a `std::convert::From<i32>` impl for convenience (so
you can call `error_code.into()` to automatically get the error enum).
Technically the `BZ2_bzCompressEnd()` destructor could fail if we pass in an
invalid stream, but if that's the case then the worst that happens is we leak
memory... So I'll just ignore errors in the `Drop` impl for now.



[openssl]: https://github.com/sfackler/rust-openssl
[git]: https://github.com/alexcrichton/git2-rs
[bindgen]: https://github.com/servo/rust-bindgen
[tut]: http://fitzgeraldnick.com/2016/12/14/using-libbindgen-in-build-rs.html
[libtcod]: https://bitbucket.org/libtcod/libtcod
[git-hg]: https://github.com/cosmin/git-hg
[ubuntu-instructions]: https://bitbucket.org/libtcod/libtcod/src/f3486b0851a2acf11efbd2df18fc06501012afef/README-linux-SDL2.md?fileviewer=file-view-default
[libbzip2]: http://www.bzip.org/1.0.5/bzip2-manual-1.0.5.html#libprog
